% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutation_factor.R
\name{evaluate.lambda.range}
\alias{evaluate.lambda.range}
\title{evaluate.lambda.range}
\usage{
evaluate.lambda.range(
  x,
  K = 6,
  beta = NULL,
  background_signature = NULL,
  nmf_runs = 10,
  lambda_values = c(0.1, 0.2, 0.3, 0.4, 0.5),
  iterations = 20,
  max_iterations_lasso = 10000,
  num_processes = Inf,
  seed = NULL,
  verbose = TRUE
)
}
\arguments{
\item{x}{count matrix.}

\item{K}{numeric value (greater than 1) indicating the number of signatures to be discovered.}

\item{beta}{starting beta for the estimation. If it is NULL, starting beta is estimated by NMF.}

\item{background_signature}{background signature to be used. If not provided, a warning is thrown.}

\item{nmf_runs}{number of iteration of NMF to be performed for a robust estimation of starting beta. If beta is not NULL, 
this parameter is ignored.}

\item{lambda_values}{range of values of LASSO to be used between 0 and 1. This value should be greater than 0. 1 is the value of LASSO 
that would shrink all the signatures to 0 within one step. The higher lambda_rate is, the sparser are the resulting signatures, 
but too large values result in a poor fit of the counts.}

\item{iterations}{Number of iterations to be performed. Each iteration correspond to a first step where the counts are fitted 
and a second step where sparsity is enhanced.}

\item{max_iterations_lasso}{Number of maximum iterations to be performed during the sparsification.}

\item{num_processes}{Number of processes to be used during parallel execution. If executing in single process mode, 
this is ignored.}

\item{seed}{Seed for reproducibility.}

\item{verbose}{boolean; Shall I print all messages?}
}
\value{
A list corresponding to results of the function nmf.LassoK for each value of lambda to be tested. This function allows 
to test a good range of lambda values to be considered. One should keep in mind that too small values generate dense solution, 
while too high ones leads to poor fit. This behavior is resampled in the values of loglik_progression, which should be increasing: 
too small values of lamda results in unstable log-likelihood through the iterations, while too large values make log-likelihood 
drop.
}
\description{
Estimate the range of lambda values to be considered in the signature inference. Note that too small values of lambda 
result in dense signatures, but too large values lead to bad fit of the counts.
}
